## ajax



### 概述



**产生原因**

> Web 程序最初的目的就是将信息（数据）放到公共的服务器，让所有网络用户都可以通过浏览器访问。

<img src="https://adminimg.hyfarsight.com/image-20210429091527894.png" alt="image-20210429091527894" style="margin: 0px;" />

**在此之前，我们可以通过以下几种方式让浏览器发出对服务端的请求，获得服务端的数据：**

- 地址栏输入地址，回车，刷新 
- 特定元素的 href 或 src 属性 
- 表单提交



> ​		这些方案都是我们无法通过或者很难通过代码的方式进行编程（对服务端发出请求并且接受服务端返回的响应）

---



​		AJAX（Asynchronous JavaScript and XML），最早出现在 2005 年的 Google Suggest，是在浏览器端进行网络编 程（发送请求、接收响应）的技术方案，它使我们可以通过 JavaScript 直接获取服务端最新的内容而不必重新加载 页面。让 Web 更能接近桌面应用的用户体验。

说白了，**AJAX 就是浏览器提供的一套 API，可以通过 JavaScript 调用，从而实现通过代码控制请求与响应。实现 网络编程。**`页面不刷新的情况下进行网络请求数据的获取`



---



### 实现ajax方式



#### XMLHttpRequest 对象

> 因为它原生的写法很鸡肋，所以大多会封装下，导致可能很多人不会自己写个ajax请求。都是用的JQuery或者Axios来请求数据的,**该方法基本使用fetch(XMLHttpRequest 的升级版)代替，简单了解即可**



**Ajax实现Demo**

1. get方法请求

   ```js
   const xhr = new XMLHttpRequest()
   // GET 请求传递参数通常使用的是问号传参,这里可以在请求地址后面加上参数，从而传递数据到服务端
       xhr.open('GET', 'http://hyfarsight.com/testAjaxGet')
       // 一般在 GET 请求时无需设置响应体，可以传 null 或者干脆不传
       xhr.send(null)
       xhr.onreadystatechange =  () => {
       if (xhr.readyState === 4) {
       console.log(xhr.responseText)
       }
   }
   // 一般情况下 URL 传递的都是参数性质的数据，而 POST 一般都是业务数据
   ```

2. post方法请求

   ```js
   var xhr = new XMLHttpRequest()
   // open 方法的第一个参数的作用就是设置请求的 method,第二个为请求路径
   xhr.open('GET', './api/http://hyfarsight.com/testAjaxPost')
   // 设置请求头中的 Content‐Type 为 application/x‐www‐form‐urlencoded
   xhr.setRequestHeader('Content‐Type', 'application/x‐www‐form‐urlencoded')
   // 格式：key1=value1&key2=value2
   xhr.send('key1=value1&key2=value2')
       xhr.onreadystatechange = function () {
       if (this.readyState === 4) {
       console.log(this.responseText)
       }
   }
   ```



#### fetch API



**fetch实现Demo**

```js
fetch('/http://hyfarsight.com/testAjaxGet')
    .then(response=>response.json())
	.then(response=> console.log(response))
```

---



### 两种请求方法比较区别

`fetch()`的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。

1. `fetch()`使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。
2. `fetch()`采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码；
3. `fetch()`通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。



---



### fetch方法详解

​	

#### 基本请求发送

**使用promise.then方式进行使用**

```js
fetch('/url')
	.then(response => {
    	console.log(response)
    	return response.json()
	})
	.then(reseult => console.log(reseult))
```

**结合 ES7 async await 进行使用**

```js
(async() => {
    const response = await fetch('/text.txt')
    console.log(response)
})()
```

---



#### response对象

> `fetch()`请求成功以后，得到的是一个 [Response 对象](https://developer.mozilla.org/en-US/docs/Web/API/Response)。它对应服务器的 HTTP 回应。

- `Response.ok`属性返回一个布尔值，表示请求是否成功，`true`对应 HTTP 请求的状态码 200 到 299，`false`对应其他的状态码。

- `Response.status`属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。

- `Response.statusText`属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回"OK"）。

- `Response.url`属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。

- `Response.redirected`属性返回一个布尔值，表示请求是否发生过跳转。

- `Response.type`属性返回请求的类型。可能的值如下：

  ```markdown
  - `basic`：普通请求，即同源请求。
  - `cors`：跨域请求。
  - `error`：网络错误，主要用于 Service Worker。
  - `opaque`：如果`fetch()`请求的`type`属性设为`no-cors`，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似`<form>`表单的那种跨域请求。
  ```

---

#### 判断请求是否成功

> `fetch()`发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，`fetch()`才会报错，其他情况都不会报错，而是认为请求成功。
>
> 这就是说，即使服务器返回的状态码是 4xx 或 5xx，`fetch()`也不会报错（即 Promise 不会变为 `rejected`状态）。
>
> 只有通过`Response.status`属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子

```js
if (response.ok) {
  // 请求成功
} else {
  // 请求失败
}
```

#### 读取数据内容方法

> `Response`对象根据服务器返回的不同类型的数据，提供了不同的读取方法。



```js
response.text()：得到文本字符串。
response.json()：得到 JSON 对象。
response.blob()：得到二进制 Blob 对象。
response.formData()：得到 FormData 表单对象。
response.arrayBuffer()：得到二进制 ArrayBuffer 对象。
```

**上面5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。**



### 指定请求方法

> `fetch()`的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。
>   HTTP 请求的方法、标头、数据体都在这个对象里面设置。

#### GET请求

```js
const response = await fetch(url, {
  method: 'GET',
  headers: {
   // 此处添加本次的请求头信息
   // "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
  }
});

(async ()=>{
    const json =  await response.json();
})()
```

#### POST请求

```js
onst response = await fetch(url, {
  method: 'POST',
  headers: {
    "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
  },
  body: 'foo=bar&lorem=ipsum',
});

(async ()=>{
    const json =  await response.json();
})()
```





## 课堂练习



- **完成下列接口的数据器请求操作，接口有返回值的情况下，将返回值渲染到界面（使用fetch方法）**

  | 请求地址                                              | 请求方法 | 请求参数                                                     | 响应值                                | 是否支持跨域请求                     |
  | ----------------------------------------------------- | -------- | ------------------------------------------------------------ | ------------------------------------- | ------------------------------------ |
  | https://duyi.hyfarsight.com/test/study/lyrics         | GET      | 无                                                           | {code :0,data:{lyrics:'some string'}} | 是 （后端cors跨域）                  |
  | https://duyi.hyfarsight.com/test/study/userinfo       | POST     | 请求头：application/json<br />参数 : {name:string,age:number}   // 为可选参数 | {code:0,data:{txt:anyString}}         | 是（后端cors跨域）                   |
  | https://duyi.hyfarsight.com/test/study/jsonpInterface | JSONP    | { callback : fn , name : string, age :string}<br />callback为必须参数，参数值为前端创建的全局函数<br />其余参数为非必选参数 | {code : 0 , data:{text : anyString}}  | **否** 前端需要使用JSONP形式进行测试 |
  | https://api.hyfarsight.com/test/proxy/testProxy       | GET      | 无                                                           | {code:0,data:{txt:anyString}}         | **否** 前端需要时用proxy进行跨域处理 |
  | https://api.hyfarsight.com/test/proxy/tuserinfo       | POST     | 请求头：application/x-www-form-urlencoded<br />参数 : name=string&age=number   // 为可选参数 | {code:0,data:{txt:anyString}}         | **否** 前端需要时用proxy进行跨域处理 |

  

  

  

  

